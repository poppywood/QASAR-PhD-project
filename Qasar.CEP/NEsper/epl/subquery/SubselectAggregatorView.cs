///////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2007 Esper Team. All rights reserved.                                /
// http://esper.codehaus.org                                                          /
// ---------------------------------------------------------------------------------- /
// The software in this package is published under the terms of the GPL license       /
// a copy of which has been included with this distribution in the license.txt file.  /
///////////////////////////////////////////////////////////////////////////////////////

using System.Collections.Generic;

using com.espertech.esper.epl.agg;
using com.espertech.esper.epl.expression;
using com.espertech.esper.events;
using com.espertech.esper.view;

namespace com.espertech.esper.epl.subquery
{
    /// <summary>
    /// View handling the insert and remove stream generated by a subselect
    /// for application to aggregation state.
    /// </summary>
	public class SubselectAggregatorView : ViewSupport
	{
	    private readonly AggregationService aggregationService;
	    private readonly ExprNode optionalFilterExpr;

	    /// <summary>Ctor.</summary>
	    /// <param name="aggregationService">for aggregating</param>
	    /// <param name="optionalFilterExpr">
	    /// for filtering the view-posted events before aggregation
	    /// </param>
	    public SubselectAggregatorView(AggregationService aggregationService, ExprNode optionalFilterExpr) {
	        this.aggregationService = aggregationService;
	        this.optionalFilterExpr = optionalFilterExpr;
	    }

	    public override void Update(EventBean[] newData, EventBean[] oldData) {
	        EventBean[] eventsPerStream = new EventBean[1];

	        if (newData != null)
	        {
	            foreach (EventBean @event in newData)
	            {
	                eventsPerStream[0] = @event;

	                bool isPass = Filter(eventsPerStream, true);
	                if (isPass)
	                {
	                    aggregationService.ApplyEnter(eventsPerStream, null);
	                }
	            }
	        }

	        if (oldData != null)
	        {
	            foreach (EventBean @event in oldData)
	            {
	                eventsPerStream[0] = @event;
	                bool isPass = Filter(eventsPerStream, false);
	                if (isPass)
	                {
	                    aggregationService.ApplyLeave(eventsPerStream, null);
	                }
	            }
	        }
	    }

	    public override EventType EventType {
            get { return Parent.EventType; }
	    }

	    public override IEnumerator<EventBean> GetEnumerator() {
	        return Parent.GetEnumerator();
	    }

	    private bool Filter(EventBean[] eventsPerStream, bool isNewData)
	    {
	        if (optionalFilterExpr == null)
	        {
	            return true;
	        }

	        bool? result = (bool?) optionalFilterExpr.Evaluate(eventsPerStream, isNewData);
	        return result ?? false;
	    }
	}
} // End of namespace
